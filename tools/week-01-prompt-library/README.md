# Prompt Library Starter Pack üìö

**Week 1 Tool | Released: Day 1**

A curated collection of proven prompts for common AI coding use cases. Start here to get immediate value in your workflow.

## üéØ What This Solves

Instead of crafting prompts from scratch every time, use these battle-tested prompts that have been refined through real-world usage. Save time, get better results, and establish patterns for your team.

## üì¶ What's Included

- **Code Generation Prompts** - Create components, functions, and features
- **Code Review Prompts** - Analyze and improve existing code
- **Refactoring Prompts** - Modernize and optimize code
- **Documentation Prompts** - Generate clear, useful docs
- **Testing Prompts** - Write comprehensive tests
- **Debugging Prompts** - Find and fix issues
- **Architecture Prompts** - Design systems and patterns

## üöÄ Quick Start

1. **Browse by category** below
2. **Copy the prompt** that fits your need
3. **Customize** with your specific context
4. **Iterate** based on results

## üìù Prompt Categories

### 1. Code Generation

#### Create a React Component
```
Create a React functional component called [ComponentName] that:
- Accepts these props: [list props]
- Implements [specific functionality]
- Uses [specific hooks/libraries]
- Has [specific styling requirements]
- Includes error handling for [specific cases]
- Is fully typed with TypeScript
- Follows React best practices

Include:
- Component code
- TypeScript interfaces
- Usage example
- Brief explanation of key decisions
```

#### Generate API Endpoint
```
Create a REST API endpoint for [resource] that:
- Handles [HTTP methods: GET, POST, etc.]
- Validates input using [validation library]
- Uses [database/ORM] for data access
- Implements proper error handling
- Returns appropriate HTTP status codes
- Includes request/response examples
- Follows [framework] best practices
```

#### Build CLI Tool
```
Create a command-line tool that:
- Accepts arguments: [list arguments]
- Performs [specific task]
- Shows progress/output in [format]
- Handles errors gracefully
- Includes help text
- Can be installed via npm/pip/etc.

Use [language/framework] and follow CLI best practices.
```

### 2. Code Review

#### General Code Review
```
Review this code for:
- Correctness and logic errors
- Performance issues
- Security vulnerabilities
- Code quality and maintainability
- Best practices adherence
- Potential bugs
- Edge cases not handled

Provide:
- Critical issues (must fix)
- Suggestions (should fix)
- Nice-to-haves (consider)
- Specific code improvements
```

#### Security Review
```
Perform a security audit of this code:
- Input validation issues
- Authentication/authorization flaws
- SQL injection risks
- XSS vulnerabilities
- Sensitive data exposure
- Insecure dependencies
- Missing security headers

Rate severity (Critical/High/Medium/Low) and provide fixes.
```

#### Performance Review
```
Analyze this code for performance:
- Time complexity issues
- Memory leaks
- Unnecessary re-renders/recomputations
- Database query optimization
- Network request efficiency
- Caching opportunities
- Bottlenecks

Provide specific optimizations with before/after examples.
```

### 3. Refactoring

#### Modernize Legacy Code
```
Refactor this legacy code to:
- Use modern [language] features (ES6+, Python 3.9+, etc.)
- Follow current best practices
- Improve readability
- Maintain backward compatibility [if needed]
- Add type hints/TypeScript
- Improve error handling
- Add documentation

Show before/after with explanations.
```

#### Extract and Organize
```
Refactor this code by:
- Extracting reusable functions/components
- Organizing into logical modules/files
- Removing duplication (DRY principle)
- Improving naming conventions
- Adding proper abstractions
- Maintaining existing functionality

Provide the refactored structure and key changes.
```

### 4. Documentation

#### Generate README
```
Create a comprehensive README for this project:
- Clear project description
- Installation instructions
- Usage examples
- API documentation (if applicable)
- Configuration options
- Contributing guidelines
- License information

Make it beginner-friendly and include code examples.
```

#### Document Function/Class
```
Generate documentation for this [function/class]:
- Purpose and overview
- Parameters/arguments (types, descriptions, defaults)
- Return value (type and description)
- Usage examples
- Edge cases and error conditions
- Related functions/classes
- Performance notes (if relevant)

Use [JSDoc/Python docstring/other] format.
```

### 5. Testing

#### Write Unit Tests
```
Write comprehensive unit tests for this [function/component]:
- Test happy path
- Test edge cases
- Test error conditions
- Test boundary values
- Achieve [X]% code coverage
- Use [testing framework]
- Follow AAA pattern (Arrange, Act, Assert)
- Include test descriptions

Provide the test file with setup/teardown if needed.
```

#### Generate Test Cases
```
Generate test cases for this feature:
- Normal operation scenarios
- Edge cases
- Error conditions
- Boundary values
- Integration points
- Performance scenarios

Format as a test matrix with:
- Test ID
- Description
- Input
- Expected output
- Priority
```

### 6. Debugging

#### Find the Bug
```
Debug this code that's experiencing [specific issue]:
- Error message: [paste error]
- Expected behavior: [describe]
- Actual behavior: [describe]
- Steps to reproduce: [list steps]

Analyze and:
- Identify the root cause
- Explain why it's happening
- Provide a fix
- Suggest prevention strategies
```

#### Performance Debugging
```
This code is slow. Help me debug:
- Current performance: [metrics/timing]
- Expected performance: [target]
- Code section: [highlight if known]
- Environment: [details]

Identify bottlenecks and provide optimized solution.
```

### 7. Architecture

#### Design System Architecture
```
Design the architecture for a [type of system] that:
- Handles [requirements]
- Scales to [scale requirements]
- Uses [technology stack]
- Follows [architectural patterns]
- Integrates with [external systems]

Provide:
- High-level diagram (text/ASCII)
- Component breakdown
- Data flow
- Technology choices with rationale
- Scalability considerations
```

#### Choose Technology Stack
```
I need to build [project description]. Help me choose:
- Frontend framework
- Backend framework
- Database
- Hosting/deployment
- Development tools

Consider:
- Team expertise
- Project scale
- Performance requirements
- Budget constraints
- Long-term maintainability

Provide recommendations with pros/cons.
```

## üí° Pro Tips

1. **Be Specific**: Include context, constraints, and requirements
2. **Iterate**: Use follow-up prompts to refine results
3. **Combine**: Chain prompts for complex tasks
4. **Customize**: Adapt these templates to your needs
5. **Save**: Keep a personal library of your best prompts

## üîÑ Iteration Pattern

```
1. Initial prompt (from library)
2. Review output
3. Refine: "Make it more [specific requirement]"
4. Review again
5. Finalize: "Add [missing piece]"
```

## üìö Example Workflow

**Task**: Create a user authentication component

1. Use "Create a React Component" prompt
2. Customize with your specific requirements
3. Use "Write Unit Tests" prompt for the component
4. Use "Generate README" prompt for documentation
5. Use "Code Review" prompt to polish

## ü§ù Contributing

Found a great prompt? Share it!
- Open a PR with your prompt
- Include use case and example
- Explain why it works well

## üìù Notes

- These prompts work best with GPT-4, Claude, or similar advanced models
- Adjust complexity based on your AI tool's capabilities
- Always review and test AI-generated code
- Use these as starting points, not final solutions

## üéØ Next Steps

- Try these prompts in your next project
- Build your own prompt library
- Share what works for you
- Check back for updates

---

**Part of The Next 100 Days Project**  
**Week 1 | Day 1 Release**

